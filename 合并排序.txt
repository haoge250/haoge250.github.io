1.合并操作（把2个有序的子序列进行合并成一个有序的序列）
2.算法设计：
(1)赋初值 i=low,j=middle+1,k=0,存放排好序的数组b[high-low+1]。i就是第一个有序序列的第一
个下标，j就是第二个有序序列的第一个下标。A[low：middle]，B[middle+1,high]。
(2)循环条件是i<=middle && j<=middle
(3)第一个有序序列下标为i与第二个有序序列下标为j比较，小值赋值给存放数组b[k]中
(4)对应序列i或j自增一，k增一。跳转到(2)。
(5)剩余的有序序列A和有序序列B赋值给存放数组b中，再把排好序的存放数组b赋值给初始数组s。
3.递归形式的合并排序（将一个无序的序列递归分成两个子序列，之后再合并成一个有序序列）
先分组 42，15，20，6，8，38，50，12
			/           \
		42,15,20,6    8,38,50,12
		  /    \       /    \
		42,15   20,6  8,38   50,12
		\      /      \      /
后排序 15,42  6,20    8,38  12,50（这开始都用到合并操作，以下都满足合并操作的条件）
		   \   /         \    /
		6,15,20,42      8,12,38,50
		     \             /
		6，8，12，15，20，38，42，50
4.时间复杂度
（1）分解：这一步计算子序列的中间位置，需要时间O（1）。
（2）解决子问题：递归求解两个规模为n/2的子问题，所需时间为2T(n/2)。
（3）合并：Merge算法可以在O（n）的时间内完成。
总运行时间:T(n){O(1),n=1; 2T(n/2)+O(n),n>1。
T(n)=2(2T(n/4)+O(n/2))+O(n)
	=4T(n/4)+2O(n)
	=8T(n/8)+3O(n)
	=2^xT(n/2^x)+xO(n)
	令n=2^x,则x=log(n)，
	那么T(n)=nT(1)+log(n)O（n）
			 =O(nlog(n))