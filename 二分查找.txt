有关二分查找：
1.思想：n个有序元素，将有序序列分成规模大致相等的两个部分，取中间元素与特定查找元素x进行
比较，如果x等于中间元素，则查找成功，如果小于中间元素就在序列的前半部分查找，否则在序列后
半部分查找。（用分治法理解）
2.算法设计：一维数组s[],变量low和变量high代表查找范围的上界和下界，middle代表查找范围的中间位
置，x为特定的查找元素,n代表元素个数。
（1）初始化。令low=0，high=n-1；
（2）middle=(low+high)/2 (这里计算的数值可能不是整数，不过没事)
(3)low<=high为循环判定条件
（4）x==s[middle]，成功找到,结束查找。x<s[middle],high=middle-1，x>s[middle],low=middle+1，转到第(2)步。
跳出循环只有2种：第一种没有元素x,就是low>high;第二种找到元素x,就是x==s[middle]
3.时间复杂度：T（n）{ O(1),n=1;T(n/2)+O(1),n>1。当n>1时,可以递推求解
T(n)=T(n/2)+O(1)
	=T(n/4)+2O(1)=T(n/2^x)+xO(1),令n=2^x，则x=log(n)
	最终时间复杂度为O（log(n)）；